/* -*- c++ -*- */
/*
 * Copyright (c) 2023 Igor Freire.
 *
 * This file is part of gr-dvbs2rx.
 *
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

#ifndef INCLUDED_DVBS2RX_GF_UTIL_H
#define INCLUDED_DVBS2RX_GF_UTIL_H

#include "gf.h"
#include <array>
#include <stdexcept>
#include <vector>

#define DIV_CEIL(a, b) (((a) + (b)-1) / (b))

namespace gr {
namespace dvbs2rx {
/**
 * @brief Build LUT to assist with GF(2) polynomial remainder computation
 *
 * The resulting LUT can be used to compute "y % x" more efficiently for any "y" and a
 * given "x". More specifically, it maps each possible input byte representative of a
 * dividend polynomial y to the bits that would leak in the succeeding bytes within the
 * remainder computation. In the end, the LUT allows for computing the remainder with one
 * iteration per byte, instead of one interation per bit.
 *
 * @param x Divisor polynomial.
 * @return std::array<T, 256> Byte-by-byte remainder look-up table.
 */
template <typename T>
std::array<T, 256> build_gf2_poly_rem_lut(const gf2_poly<T>& x)
{
    // As the divisor x is bit-shifted and XORed over the bits of an input byte, the
    // result may leak over up to x.degree() bits following the given byte. In other
    // words, the remainder in the division by x has degree up to "x.degree() -1", which
    // occupies up to x.degree() bits.
    const unsigned int n_leak_bytes = DIV_CEIL(x.degree(), 8);

    // To compute the leak, each possible input byte is zero-padded with n_leak_bytes
    // bytes. Hence, type T must be able to fit "n_leak_bytes + 1" bytes.
    if (sizeof(T) < n_leak_bytes + 1)
        throw std::runtime_error("Failed to compute remainder LUT. Type does not fit.");

    std::array<T, 256> table;
    for (int i = 0; i < 256; i++) {
        T padded_in_byte = static_cast<T>(i) << (n_leak_bytes * 8);
        gf2_poly<T> y(padded_in_byte);
        table[i] = (y % x).get_poly();
    }
    return table;
}

/**
 * @brief Compute the remainder "y % x" of GF2 polynomials y and x using a LUT
 *
 * @param y Dividend GF(2) polynomial given by a vector of bytes in network byte order
 * (big-endian), i.e., with the most significant byte in the first position (index 0).
 * @param x Divisor GF(2) polynomial.
 * @param x_lut LUT generated by the `build_gf2_poly_rem_lut` function for polynomial x.
 * @return gf2_poly<T> Resulting remainder.
 */
template <typename T>
gf2_poly<T> gf2_poly_rem(const std::vector<uint8_t>& y,
                         const gf2_poly<T>& x,
                         const std::array<T, 256>& x_lut)
{
    const int n_leak_bytes = DIV_CEIL(x.degree(), 8); // see build_gf2_poly_rem_lut
    const int n_in_bytes = y.size();
    const T bits_after_msby = (n_leak_bytes - 1) * 8;
    const T leak_mask = (static_cast<T>(1) << (n_leak_bytes * 8)) - 1;

    // Over the first "n_in_bytes - n_leak_bytes" bytes, iteratively look up the leak that
    // the input byte introduces into the next n_leak_bytes bytes.
    T leak = 0;
    for (int i = 0; i < n_in_bytes - n_leak_bytes; i++) {
        // Incorporate the preceding leak into the input byte. The leak spans over
        // n_leak_bytes of the type-T word, and the resulting most significant byte (MSBy)
        // determines the next leak. The other bytes (other than the MSBy) from the
        // preceding leak continue to leak (are carried forward) over the next bytes.
        T padded_in_byte = static_cast<T>(y[i]) << bits_after_msby;
        uint8_t msby = (leak ^ padded_in_byte) >> bits_after_msby;
        T leak_carried_forward = (leak_mask & (leak << 8));
        leak = leak_carried_forward ^ x_lut[msby];
    }

    // The last n_leak_bytes are converted into a word of type T following the assumed
    // network byte order. Note that n_leak_bytes is guaranteed to fit in T, otherwise
    // build_gf2_poly_rem_lut would throw an exception.
    T y_last_bytes = 0;
    for (int i = 0; i < std::min(n_leak_bytes, n_in_bytes); i++) {
        y_last_bytes ^= static_cast<T>(y[n_in_bytes - i - 1]) << (i * 8);
    }

    // Incorporate the leak from the preceding bytes, if any
    y_last_bytes ^= leak;

    return gf2_poly<T>(y_last_bytes) % x;
}

/**
 * @brief Test if bit is set
 *
 * @param x Bit register.
 * @param i_bit Target bit index.
 * @return true if bit is 1 and false otherwise.
 */
template <typename T>
inline bool is_bit_set(const T& x, int i_bit)
{
    return x & (static_cast<T>(1) << i_bit);
}

} // namespace dvbs2rx
} // namespace gr

#endif // INCLUDED_DVBS2RX_GF_UTIL_H