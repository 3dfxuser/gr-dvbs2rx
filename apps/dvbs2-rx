#!/usr/bin/env python3
# -*- coding: utf-8 -*-

#
# SPDX-License-Identifier: GPL-3.0
#
# DVB-S2 Rx
#
# Full DVB-S2 receiver. Processes input IQ samples and outputs MPEG TS packets.

import ctypes
import signal
import sys
from argparse import ArgumentParser, ArgumentDefaultsHelpFormatter
from distutils.version import StrictVersion

import sip
from PyQt5 import Qt
from gnuradio import analog
from gnuradio import blocks
from gnuradio import digital
from gnuradio import eng_notation
from gnuradio import filter
from gnuradio import gr
from gnuradio import qtgui
from gnuradio.eng_arg import eng_float, intx
from gnuradio.fft import window
from gnuradio.filter import firdes

import dvbs2rx


class dvbs2_rx(gr.top_block, Qt.QWidget):
    def __init__(self, options):
        gr.top_block.__init__(self, "DVB-S2 Rx", catch_exceptions=True)

        ##################################################
        # Parameters
        ##################################################
        self.agc_gain = options.agc_gain
        self.agc_rate = options.agc_rate
        self.agc_ref = options.agc_ref
        self.debug = options.debug
        self.frame_size = options.frame_size
        self.freq = options.freq
        self.gain = options.gain
        self.gold_code = options.gold_code
        self.gui = options.gui
        self.in_fd = options.in_fd
        self.in_file = options.in_file
        self.in_repeat = options.in_repeat
        self.modcod = options.modcod
        self.multistream = options.multistream
        self.out_fd = options.out_fd
        self.out_file = options.out_file
        self.pilots = options.pilots
        self.pl_acm_vcm = options.pl_acm_vcm
        self.pl_freq_est_period = options.pl_freq_est_period
        self.rolloff = options.rolloff
        self.rot_max_buf = options.rot_max_buf
        self.rrc_delay = options.rrc_delay
        self.rrc_nfilts = options.rrc_nfilts
        self.rtl_idx = options.rtl_idx
        self.rtl_agc = options.rtl_agc
        self.rtl_serial = options.rtl_serial
        self.sink = options.sink
        self.source = options.source
        self.spectral_inversion = options.spectral_inversion
        self.sps = options.sps
        self.sym_rate = options.sym_rate
        self.sym_sync_damping = options.sym_sync_damping
        self.sym_sync_impl = options.sym_sync_impl
        self.sym_sync_loop_bw = options.sym_sync_loop_bw
        self.usrp_addr = options.usrp_addr
        self.usrp_antenna = options.usrp_antenna

        ##################################################
        # Variables
        ##################################################
        code_rate = self.modcod.upper().replace("8PSK", "").replace("QPSK", "")
        self.code_rate = code_rate
        self.samp_rate = self.sym_rate * self.sps
        self.plheader_len = 90
        self.plframe_len = 33282
        self.pilot_len = int((360 - 1) / 16) * 36
        self.n_rrc_taps = int(self.rrc_delay * self.sps) + 1
        self.constellation = self.modcod.replace(code_rate, "")

        if (self.gui):
            self.setup_gui()
        source_block = self.connect_source()
        sink_block = self.connect_sink()
        self.connect_dvbs2rx(source_block, sink_block)

    def setup_gui(self):
        Qt.QWidget.__init__(self)
        self.setWindowTitle("DVB-S2 Rx")
        qtgui.util.check_set_qss()
        try:
            self.setWindowIcon(Qt.QIcon.fromTheme('gnuradio-grc'))
        except:
            pass
        self.top_scroll_layout = Qt.QVBoxLayout()
        self.setLayout(self.top_scroll_layout)
        self.top_scroll = Qt.QScrollArea()
        self.top_scroll.setFrameStyle(Qt.QFrame.NoFrame)
        self.top_scroll_layout.addWidget(self.top_scroll)
        self.top_scroll.setWidgetResizable(True)
        self.top_widget = Qt.QWidget()
        self.top_scroll.setWidget(self.top_widget)
        self.top_layout = Qt.QVBoxLayout(self.top_widget)
        self.top_grid_layout = Qt.QGridLayout()
        self.top_layout.addLayout(self.top_grid_layout)

        self.settings = Qt.QSettings("GNU Radio", "dvbs2_rx")

        try:
            if StrictVersion(Qt.qVersion()) < StrictVersion("5.0.0"):
                self.restoreGeometry(
                    self.settings.value("geometry").toByteArray())
            else:
                self.restoreGeometry(self.settings.value("geometry"))
        except:
            pass

        ##################################################
        # Blocks
        ##################################################
        self.tabs = Qt.QTabWidget()
        self.tabs_widget_0 = Qt.QWidget()
        self.tabs_layout_0 = Qt.QBoxLayout(Qt.QBoxLayout.TopToBottom,
                                           self.tabs_widget_0)
        self.tabs_grid_layout_0 = Qt.QGridLayout()
        self.tabs_layout_0.addLayout(self.tabs_grid_layout_0)
        self.tabs.addTab(self.tabs_widget_0, 'Input')
        self.tabs_widget_1 = Qt.QWidget()
        self.tabs_layout_1 = Qt.QBoxLayout(Qt.QBoxLayout.TopToBottom,
                                           self.tabs_widget_1)
        self.tabs_grid_layout_1 = Qt.QGridLayout()
        self.tabs_layout_1.addLayout(self.tabs_grid_layout_1)
        self.tabs.addTab(self.tabs_widget_1, 'Frequency Correction')
        self.tabs_widget_2 = Qt.QWidget()
        self.tabs_layout_2 = Qt.QBoxLayout(Qt.QBoxLayout.TopToBottom,
                                           self.tabs_widget_2)
        self.tabs_grid_layout_2 = Qt.QGridLayout()
        self.tabs_layout_2.addLayout(self.tabs_grid_layout_2)
        self.tabs.addTab(self.tabs_widget_2, 'Symbol Sync')
        self.tabs_widget_3 = Qt.QWidget()
        self.tabs_layout_3 = Qt.QBoxLayout(Qt.QBoxLayout.TopToBottom,
                                           self.tabs_widget_3)
        self.tabs_grid_layout_3 = Qt.QGridLayout()
        self.tabs_layout_3.addLayout(self.tabs_grid_layout_3)
        self.tabs.addTab(self.tabs_widget_3, 'Frame Recovery')
        self.tabs_widget_4 = Qt.QWidget()
        self.tabs_layout_4 = Qt.QBoxLayout(Qt.QBoxLayout.TopToBottom,
                                           self.tabs_widget_4)
        self.tabs_grid_layout_4 = Qt.QGridLayout()
        self.tabs_layout_4.addLayout(self.tabs_grid_layout_4)
        self.tabs.addTab(self.tabs_widget_4, 'Phase Recovery')
        self.top_grid_layout.addWidget(self.tabs, 0, 0, 1, 1)
        for r in range(0, 1):
            self.top_grid_layout.setRowStretch(r, 1)
        for c in range(0, 1):
            self.top_grid_layout.setColumnStretch(c, 1)
        self.qtgui_waterfall_sink_x_0 = qtgui.waterfall_sink_c(
            1024,  # size
            window.WIN_BLACKMAN_hARRIS,  # wintype
            0,  # fc
            self.samp_rate,  # bw
            "Spectrogram",  # name
            1,  # number of inputs
            None  # parent
        )
        self.qtgui_waterfall_sink_x_0.set_update_time(0.10)
        self.qtgui_waterfall_sink_x_0.enable_grid(False)
        self.qtgui_waterfall_sink_x_0.enable_axis_labels(True)

        labels = ['', '', '', '', '', '', '', '', '', '']
        colors = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        alphas = [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]

        for i in range(1):
            if len(labels[i]) == 0:
                self.qtgui_waterfall_sink_x_0.set_line_label(
                    i, "Data {0}".format(i))
            else:
                self.qtgui_waterfall_sink_x_0.set_line_label(i, labels[i])
            self.qtgui_waterfall_sink_x_0.set_color_map(i, colors[i])
            self.qtgui_waterfall_sink_x_0.set_line_alpha(i, alphas[i])

        self.qtgui_waterfall_sink_x_0.set_intensity_range(-140, 10)

        self._qtgui_waterfall_sink_x_0_win = sip.wrapinstance(
            self.qtgui_waterfall_sink_x_0.pyqwidget(), Qt.QWidget)
        self.tabs_grid_layout_0.addWidget(self._qtgui_waterfall_sink_x_0_win,
                                          0, 0, 1, 3)
        for r in range(0, 1):
            self.tabs_grid_layout_0.setRowStretch(r, 1)
        for c in range(0, 3):
            self.tabs_grid_layout_0.setColumnStretch(c, 1)
        self.qtgui_time_sink_x_1 = qtgui.time_sink_c(
            self.plframe_len - self.pilot_len - self.plheader_len,  # size
            self.sym_rate,  # samp_rate
            "",  # name
            1,  # number of inputs
            None  # parent
        )
        self.qtgui_time_sink_x_1.set_update_time(0.10)
        self.qtgui_time_sink_x_1.set_y_axis(-1, 1)

        self.qtgui_time_sink_x_1.set_y_label('PLFRAME Symbols', "")

        self.qtgui_time_sink_x_1.enable_tags(True)
        self.qtgui_time_sink_x_1.set_trigger_mode(qtgui.TRIG_MODE_FREE,
                                                  qtgui.TRIG_SLOPE_POS, 0.0, 0,
                                                  0, "")
        self.qtgui_time_sink_x_1.enable_autoscale(True)
        self.qtgui_time_sink_x_1.enable_grid(True)
        self.qtgui_time_sink_x_1.enable_axis_labels(True)
        self.qtgui_time_sink_x_1.enable_control_panel(False)
        self.qtgui_time_sink_x_1.enable_stem_plot(False)

        labels = [
            'I', 'Q', 'Signal 3', 'Signal 4', 'Signal 5', 'Signal 6',
            'Signal 7', 'Signal 8', 'Signal 9', 'Signal 10'
        ]
        widths = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        colors = [
            'blue', 'red', 'green', 'black', 'cyan', 'magenta', 'yellow',
            'dark red', 'dark green', 'dark blue'
        ]
        alphas = [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]
        styles = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        markers = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]

        for i in range(2):
            if len(labels[i]) == 0:
                if (i % 2 == 0):
                    self.qtgui_time_sink_x_1.set_line_label(
                        i, "Re{{Data {0}}}".format(i / 2))
                else:
                    self.qtgui_time_sink_x_1.set_line_label(
                        i, "Im{{Data {0}}}".format(i / 2))
            else:
                self.qtgui_time_sink_x_1.set_line_label(i, labels[i])
            self.qtgui_time_sink_x_1.set_line_width(i, widths[i])
            self.qtgui_time_sink_x_1.set_line_color(i, colors[i])
            self.qtgui_time_sink_x_1.set_line_style(i, styles[i])
            self.qtgui_time_sink_x_1.set_line_marker(i, markers[i])
            self.qtgui_time_sink_x_1.set_line_alpha(i, alphas[i])

        self._qtgui_time_sink_x_1_win = sip.wrapinstance(
            self.qtgui_time_sink_x_1.pyqwidget(), Qt.QWidget)
        self.tabs_layout_3.addWidget(self._qtgui_time_sink_x_1_win)
        self.qtgui_number_sink_0 = qtgui.number_sink(
            gr.sizeof_float,
            0,
            qtgui.NUM_GRAPH_VERT,
            1,
            None  # parent
        )
        self.qtgui_number_sink_0.set_update_time(0.10)
        self.qtgui_number_sink_0.set_title("RMS Level")

        labels = ['', '', '', '', '', '', '', '', '', '']
        units = ['', '', '', '', '', '', '', '', '', '']
        colors = [("black", "black"), ("black", "black"), ("black", "black"),
                  ("black", "black"), ("black", "black"), ("black", "black"),
                  ("black", "black"), ("black", "black"), ("black", "black"),
                  ("black", "black")]
        factor = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]

        for i in range(1):
            self.qtgui_number_sink_0.set_min(i, -1)
            self.qtgui_number_sink_0.set_max(i, 1)
            self.qtgui_number_sink_0.set_color(i, colors[i][0], colors[i][1])
            if len(labels[i]) == 0:
                self.qtgui_number_sink_0.set_label(i, "Data {0}".format(i))
            else:
                self.qtgui_number_sink_0.set_label(i, labels[i])
            self.qtgui_number_sink_0.set_unit(i, units[i])
            self.qtgui_number_sink_0.set_factor(i, factor[i])

        self.qtgui_number_sink_0.enable_autoscale(False)
        self._qtgui_number_sink_0_win = sip.wrapinstance(
            self.qtgui_number_sink_0.pyqwidget(), Qt.QWidget)
        self.tabs_grid_layout_0.addWidget(self._qtgui_number_sink_0_win, 0, 3,
                                          1, 1)
        for r in range(0, 1):
            self.tabs_grid_layout_0.setRowStretch(r, 1)
        for c in range(3, 4):
            self.tabs_grid_layout_0.setColumnStretch(c, 1)
        self.qtgui_freq_sink_x_0 = qtgui.freq_sink_c(
            1024,  # size
            window.WIN_BLACKMAN_hARRIS,  # wintype
            0,  # fc
            self.samp_rate,  # bw
            "Frequency Correction",  # name
            2,
            None  # parent
        )
        self.qtgui_freq_sink_x_0.set_update_time(0.10)
        self.qtgui_freq_sink_x_0.set_y_axis(-140, 10)
        self.qtgui_freq_sink_x_0.set_y_label('Relative Gain', 'dB')
        self.qtgui_freq_sink_x_0.set_trigger_mode(qtgui.TRIG_MODE_FREE, 0.0, 0,
                                                  "")
        self.qtgui_freq_sink_x_0.enable_autoscale(False)
        self.qtgui_freq_sink_x_0.enable_grid(True)
        self.qtgui_freq_sink_x_0.set_fft_average(0.05)
        self.qtgui_freq_sink_x_0.enable_axis_labels(True)
        self.qtgui_freq_sink_x_0.enable_control_panel(False)
        self.qtgui_freq_sink_x_0.set_fft_window_normalized(False)

        labels = ['Before', 'After', '', '', '', '', '', '', '', '']
        widths = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        colors = [
            "blue", "red", "green", "black", "cyan", "magenta", "yellow",
            "dark red", "dark green", "dark blue"
        ]
        alphas = [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]

        for i in range(2):
            if len(labels[i]) == 0:
                self.qtgui_freq_sink_x_0.set_line_label(
                    i, "Data {0}".format(i))
            else:
                self.qtgui_freq_sink_x_0.set_line_label(i, labels[i])
            self.qtgui_freq_sink_x_0.set_line_width(i, widths[i])
            self.qtgui_freq_sink_x_0.set_line_color(i, colors[i])
            self.qtgui_freq_sink_x_0.set_line_alpha(i, alphas[i])

        self._qtgui_freq_sink_x_0_win = sip.wrapinstance(
            self.qtgui_freq_sink_x_0.pyqwidget(), Qt.QWidget)
        self.tabs_layout_1.addWidget(self._qtgui_freq_sink_x_0_win)
        self.qtgui_const_sink_x_1_0 = qtgui.const_sink_c(
            1024,  # size
            "Symbol Sync Output",  # name
            1,  # number of inputs
            None  # parent
        )
        self.qtgui_const_sink_x_1_0.set_update_time(0.10)
        self.qtgui_const_sink_x_1_0.set_y_axis(-2, 2)
        self.qtgui_const_sink_x_1_0.set_x_axis(-2, 2)
        self.qtgui_const_sink_x_1_0.set_trigger_mode(qtgui.TRIG_MODE_FREE,
                                                     qtgui.TRIG_SLOPE_POS, 0.0,
                                                     0, "")
        self.qtgui_const_sink_x_1_0.enable_autoscale(False)
        self.qtgui_const_sink_x_1_0.enable_grid(False)
        self.qtgui_const_sink_x_1_0.enable_axis_labels(True)

        self.qtgui_const_sink_x_1_0.disable_legend()

        labels = ['', '', '', '', '', '', '', '', '', '']
        widths = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        colors = [
            "blue", "red", "red", "red", "red", "red", "red", "red", "red",
            "red"
        ]
        styles = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        markers = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        alphas = [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]

        for i in range(1):
            if len(labels[i]) == 0:
                self.qtgui_const_sink_x_1_0.set_line_label(
                    i, "Data {0}".format(i))
            else:
                self.qtgui_const_sink_x_1_0.set_line_label(i, labels[i])
            self.qtgui_const_sink_x_1_0.set_line_width(i, widths[i])
            self.qtgui_const_sink_x_1_0.set_line_color(i, colors[i])
            self.qtgui_const_sink_x_1_0.set_line_style(i, styles[i])
            self.qtgui_const_sink_x_1_0.set_line_marker(i, markers[i])
            self.qtgui_const_sink_x_1_0.set_line_alpha(i, alphas[i])

        self._qtgui_const_sink_x_1_0_win = sip.wrapinstance(
            self.qtgui_const_sink_x_1_0.pyqwidget(), Qt.QWidget)
        self.tabs_layout_2.addWidget(self._qtgui_const_sink_x_1_0_win)
        self.qtgui_const_sink_x_1 = qtgui.const_sink_c(
            1024,  # size
            "PL Sync Output",  # name
            1,  # number of inputs
            None  # parent
        )
        self.qtgui_const_sink_x_1.set_update_time(0.10)
        self.qtgui_const_sink_x_1.set_y_axis(-2, 2)
        self.qtgui_const_sink_x_1.set_x_axis(-2, 2)
        self.qtgui_const_sink_x_1.set_trigger_mode(qtgui.TRIG_MODE_FREE,
                                                   qtgui.TRIG_SLOPE_POS, 0.0,
                                                   0, "")
        self.qtgui_const_sink_x_1.enable_autoscale(False)
        self.qtgui_const_sink_x_1.enable_grid(False)
        self.qtgui_const_sink_x_1.enable_axis_labels(True)

        self.qtgui_const_sink_x_1.disable_legend()

        labels = ['', '', '', '', '', '', '', '', '', '']
        widths = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        colors = [
            "blue", "red", "red", "red", "red", "red", "red", "red", "red",
            "red"
        ]
        styles = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        markers = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        alphas = [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]

        for i in range(1):
            if len(labels[i]) == 0:
                self.qtgui_const_sink_x_1.set_line_label(
                    i, "Data {0}".format(i))
            else:
                self.qtgui_const_sink_x_1.set_line_label(i, labels[i])
            self.qtgui_const_sink_x_1.set_line_width(i, widths[i])
            self.qtgui_const_sink_x_1.set_line_color(i, colors[i])
            self.qtgui_const_sink_x_1.set_line_style(i, styles[i])
            self.qtgui_const_sink_x_1.set_line_marker(i, markers[i])
            self.qtgui_const_sink_x_1.set_line_alpha(i, alphas[i])

        self._qtgui_const_sink_x_1_win = sip.wrapinstance(
            self.qtgui_const_sink_x_1.pyqwidget(), Qt.QWidget)
        self.tabs_layout_4.addWidget(self._qtgui_const_sink_x_1_win)

    def connect_source(self):
        """Connect the IQ sample source

        Returns:
            block: Last block object on the source pipeline, which should
            connect to the DVB-S2 Rx input.
        """
        if (self.source == "fd" or self.source == "file"):
            if (self.source == "fd"):
                blocks_file_or_fd_source = blocks.file_descriptor_source(
                    gr.sizeof_char, self.in_fd, False)
            else:
                blocks_file_or_fd_source = blocks.file_source(
                    gr.sizeof_char, self.in_file, self.in_repeat)
            # Pipeline to convert the fd/file IQ stream into a complex stream,
            # assuming the independent I and Q are uint8_t streams.
            blocks_deinterleave = blocks.deinterleave(gr.sizeof_char, 1)
            blocks_uchar_to_float_0 = blocks.uchar_to_float()
            blocks_uchar_to_float_1 = blocks.uchar_to_float()
            blocks_add_const_ff_0 = blocks.add_const_ff(-127)
            blocks_add_const_ff_1 = blocks.add_const_ff(-127)
            blocks_multiply_const_ff_1 = blocks.multiply_const_ff(1 / 128)
            blocks_multiply_const_ff_0 = blocks.multiply_const_ff(1 / 128)
            blocks_float_to_complex_0 = blocks.float_to_complex(1)
            blocks_throttle_0 = blocks.throttle(gr.sizeof_gr_complex,
                                                self.samp_rate, True)
            self.connect((blocks_file_or_fd_source, 0),
                         (blocks_deinterleave, 0))
            self.connect(
                (blocks_deinterleave, 0), (blocks_uchar_to_float_0, 0),
                (blocks_add_const_ff_0, 0), (blocks_multiply_const_ff_0, 0),
                (blocks_float_to_complex_0, 0))
            self.connect(
                (blocks_deinterleave, 1), (blocks_uchar_to_float_1, 0),
                (blocks_add_const_ff_1, 0), (blocks_multiply_const_ff_1, 0),
                (blocks_float_to_complex_0, 1))
            self.connect((blocks_float_to_complex_0, 0),
                         (blocks_throttle_0, 0))
            source = blocks_throttle_0
        elif (self.source == "rtl"):
            import osmosdr  # lazy import to avoid failure if source != rtl
            rtl_arg = self.rtl_serial if (self.rtl_serial
                                          is not None) else str(self.rtl_idx)
            rtlsdr = osmosdr.source(args="numchan=" + str(1) + " " +
                                    "rtl={}".format(rtl_arg))
            rtlsdr.set_time_unknown_pps(osmosdr.time_spec_t())
            rtlsdr.set_sample_rate(self.samp_rate)
            rtlsdr.set_center_freq(self.freq, 0)
            rtlsdr.set_freq_corr(0, 0)
            rtlsdr.set_dc_offset_mode(0, 0)
            rtlsdr.set_iq_balance_mode(0, 0)
            rtlsdr.set_gain_mode(self.rtl_agc, 0)
            rtlsdr.set_gain(self.gain, 0)
            rtlsdr.set_if_gain(20, 0)
            rtlsdr.set_bb_gain(20, 0)
            rtlsdr.set_antenna('', 0)
            rtlsdr.set_bandwidth(0, 0)
            source = rtlsdr
        elif (self.source == "usrp"):
            from gnuradio import uhd
            usrp = uhd.usrp_source(
                ",".join((self.usrp_addr, '')),
                uhd.stream_args(
                    cpu_format="fc32",
                    args='',
                    channels=list(range(0, 1)),
                ))
            usrp.set_samp_rate(self.samp_rate)
            usrp.set_time_unknown_pps(uhd.time_spec(0))
            usrp.set_center_freq(self.freq, 0)
            usrp.set_antenna(self.usrp_antenna, 0)
            usrp.set_gain(self.gain, 0)
            source = usrp

        if (self.gui):
            self.blocks_rms_xx_0 = blocks.rms_cf(0.0001)
            self.connect((source, 0), (self.blocks_rms_xx_0, 0))
            self.connect((source, 0), (self.qtgui_waterfall_sink_x_0, 0))
            self.connect((self.blocks_rms_xx_0, 0),
                         (self.qtgui_number_sink_0, 0))

        return source

    def connect_sink(self):
        """Connect the MPEG TS Sink

        Returns:
            block: First block on the sink pipeline, which should connect to
            the DVB-S2 Rx output.
        """
        if (self.sink == "fd"):
            sink = blocks.file_descriptor_sink(gr.sizeof_char, self.out_fd)
        elif (self.sink == "file"):
            sink = blocks.file_sink(gr.sizeof_char, self.out_file)
        return sink

    def _plsync_params(self):
        """Get the PL Sync input parameters

        Defines the PLS filters to be used on the PL Sync block.

        Although the PL Sync block supports ACM/VCM, the remaining blocks of
        the receiver pipeline do not support these modes yet. Instead, the
        remaining blocks (e.g., BCH and LDPC decoders) must be configured for
        the specific MODCOD and frame size of interest, so these parameters
        must be known a priori.

        Meanwhile, there is still some flexibility on the pilot and SIS/MIS
        configuration assigned to the PL Sync block. For example, one could
        know a priori whether the input signal contains pilots or not. In this
        case, it is better to configure the PLS filters accordingly. Similarly,
        it could be known a priori that the input signal is based on SIS only,
        in which case it is better to configure "--multistream=off" instead of
        "on" or "auto". Generally speaking, the more a priori information the
        user provides to the PL Sync block, the better for performance.

        Also, in some cases, the user may not know the specific MODCOD and
        frame size of the underlying signal, even though these are required
        parameters. In this scenario, it is useful to force the PL Sync block
        into ACM/VCM mode (using option "--pl-acm-vcm") and enable the debug
        logs with option "--debug=1" or greater. By doing so, the decoded PLSC
        information will be printed to the console, so the user can later
        relaunch the application with the appropriate parameters.

        Returns:
            tuple: Tuple with the parameters for the PL Sync block.

        """

        # Get the target CCM-mode PLS. If the pilot configuration is set to
        # auto, allow the two PLS values corresponding to the same MODCOD and
        # frame size, with and without pilots.
        target_pls = list()
        if (self.pilots == "auto"):
            for pilots_enabled in [False, True]:
                target_pls.append(
                    dvbs2rx.params.dvbs2_pls(self.constellation,
                                             self.code_rate, self.frame_size,
                                             pilots_enabled))
        else:
            pilots_enabled = self.pilots == "on"
            target_pls.append(
                dvbs2rx.params.dvbs2_pls(self.constellation, self.code_rate,
                                         self.frame_size, pilots_enabled))

        # Convert into the corresponding filter bitmasks
        pls_filter_lo, pls_filter_hi = dvbs2rx.params.pls_filter(*target_pls)

        # SIS or MIS? When unsure, it's better to enable MIS so that dummy
        # PLFRAMEs can be processed. Auto mode is the same as leaving MIS on.
        multistream_enabled = self.multistream in ["auto", "on"]

        return (self.gold_code, self.pl_freq_est_period, self.sps, self.debug,
                self.pl_acm_vcm, multistream_enabled, pls_filter_lo,
                pls_filter_hi)

    def connect_dvbs2rx(self, source_block, sink_block):
        """Connect the DVB-S2 Rx Pipeline

        Implement the following pipeline:

        IQ Input -> AGC -> Rotator -> Symbol Synch -> DVB-S2 PL Sync  ->|
                                                                        |
                                                                        |
        MPEG TS Output <- BBFRAME Processing <- BCH Dec. <- LDPC Dec. <-|

        Args:
            source_block : The block providing IQ samples into the DVB-S2 Rx.
            sink_block : The block consuming the MPEG TS output stream.

        """
        translated_params = dvbs2rx.params.translate('DVB-S2', self.frame_size,
                                                     self.code_rate,
                                                     self.constellation)
        standard, frame_size, code_rate, constellation = translated_params

        # Upper layer (FEC + BB Processing)
        ldpc_decoder = dvbs2rx.ldpc_decoder_cb(standard, frame_size, code_rate,
                                               constellation,
                                               dvbs2rx.OM_MESSAGE,
                                               dvbs2rx.INFO_OFF)
        bch_decoder = dvbs2rx.bch_decoder_bb(standard, frame_size, code_rate,
                                             dvbs2rx.OM_MESSAGE)
        bbdescrambler = dvbs2rx.bbdescrambler_bb(standard, frame_size,
                                                 code_rate)
        bbdeheader = dvbs2rx.bbdeheader_bb(standard, frame_size, code_rate)

        self.connect((ldpc_decoder, 0), (bch_decoder, 0), (bbdescrambler, 0),
                     (bbdeheader, 0), (sink_block, 0))

        # Low layer (PHY)

        # Automatic gain control (AGC) stage - preceding the rotator
        analog_agc = analog.agc_cc(self.agc_rate, self.agc_ref, self.agc_gain)
        analog_agc.set_max_gain(65536)

        # Rotator (frequency offset correction)
        rotator = blocks.rotator_cc(0, True)
        if (self.rot_max_buf is not None):
            rotator.set_max_output_buffer(self.rot_max_buf)
        self.connect((analog_agc, 0), (rotator, 0))

        # Optional IQ swapping stage - preceding the AGC-rotator blocks
        first_block = analog_agc
        if (self.spectral_inversion):
            iq_swap = blocks.swap_iq(1, gr.sizeof_gr_complex)
            self.connect((iq_swap, 0), (first_block, 0))
            first_block = iq_swap

        # Symbol timing synchronizer - after the rotator
        if (self.sym_sync_impl == "in-tree"):
            symbol_sync = digital.symbol_sync_cc(
                digital.TED_GARDNER, self.sps, self.sym_sync_loop_bw,
                self.sym_sync_damping, 1.0, 1.5, 1,
                digital.constellation_bpsk().base(), digital.IR_PFB_MF,
                self.rrc_nfilts,
                firdes.root_raised_cosine(self.rrc_nfilts,
                                          self.samp_rate * self.rrc_nfilts,
                                          self.sym_rate, self.rolloff,
                                          self.n_rrc_taps * self.rrc_nfilts))
            self.connect((rotator, 0), (symbol_sync, 0))
        else:
            rrc_filter = filter.fir_filter_ccf(
                1,
                firdes.root_raised_cosine(1, self.sps, 1.0, self.rolloff,
                                          self.n_rrc_taps))
            symbol_sync = dvbs2rx.symbol_sync_cc(self.sps,
                                                 self.sym_sync_loop_bw,
                                                 self.sym_sync_damping,
                                                 self.rolloff)
            self.connect((rotator, 0), (rrc_filter, 0), (symbol_sync, 0))

        # PL Sync - after the symbol synchronizer and before the LDPC decoder
        plsync = dvbs2rx.plsync_cc(*self._plsync_params())
        self.msg_connect((plsync, 'rotator_phase_inc'), (rotator, 'cmd'))
        self.connect((plsync, 0), (ldpc_decoder, 0))
        self.connect((symbol_sync, 0), (plsync, 0))

        # Connect the source to the first block
        self.connect((source_block, 0), (first_block, 0))

        if (self.gui):
            self.connect((symbol_sync, 0), (self.qtgui_const_sink_x_1_0, 0))
            self.connect((plsync, 0), (self.qtgui_const_sink_x_1, 0))
            self.connect((plsync, 0), (self.qtgui_time_sink_x_1, 0))
            self.connect((analog_agc, 0), (self.qtgui_freq_sink_x_0, 0))
            self.connect((rotator, 0), (self.qtgui_freq_sink_x_0, 1))

    def closeEvent(self, event):
        self.settings = Qt.QSettings("GNU Radio", "dvbs2_rx")
        self.settings.setValue("geometry", self.saveGeometry())
        self.stop()
        self.wait()
        event.accept()


def argument_parser():
    description = 'DVB-S2 receiver'
    parser = ArgumentParser(prog="dvbs2-rx",
                            description=description,
                            formatter_class=ArgumentDefaultsHelpFormatter)
    parser.add_argument("--agc-gain",
                        type=eng_float,
                        default=eng_notation.num_to_str(float(1)),
                        help="AGC gain")
    parser.add_argument("--agc-rate",
                        type=eng_float,
                        default=eng_notation.num_to_str(float(1e-5)),
                        help="AGC update rate")
    parser.add_argument("--agc-ref",
                        type=eng_float,
                        default=eng_notation.num_to_str(float(1)),
                        help="AGC's reference value")
    parser.add_argument("-d",
                        "--debug",
                        type=int,
                        default=0,
                        help="Debugging level")
    parser.add_argument("--frame-size",
                        type=str,
                        choices=['normal', 'short'],
                        default='normal',
                        help="FECFRAME size")
    parser.add_argument(
        '-p',
        "--pilots",
        choices=['on', 'off', 'auto'],
        default='auto',
        help="Whether the expected PLFRAMEs contain pilots. Choose \"auto\" "
        "if unsure. Otherwise, choose \"on\" or \"off\" for better performance"
    )
    parser.add_argument('-f',
                        "--freq",
                        type=eng_float,
                        default=eng_notation.num_to_str(float(1e9)),
                        help="Carrier or intermediate frequency in Hz")
    parser.add_argument('-g',
                        "--gain",
                        type=float,
                        default=0,
                        help="Receiver gain")
    parser.add_argument("--gold-code", type=intx, default=0, help="Gold code")
    parser.add_argument("--gui",
                        action='store_true',
                        default=False,
                        help="Launch a graphical user interface (GUI).")
    parser.add_argument("-m",
                        "--modcod",
                        type=str,
                        default='QPSK1/4',
                        help="Target MODCOD")
    parser.add_argument(
        "--multistream",
        choices=['on', 'off', 'auto'],
        default='auto',
        help="Enable processing of multiple input streams (MIS mode). Set to "
        "\"auto\" if unsure about whether the input signal uses SIS or MIS. "
        "Otherwise, choose \"on\" or \"off\" for better performance.")
    parser.add_argument(
        "--pl-freq-est-period",
        type=int,
        default=30,
        help="Coarse frequency offset estimation period in frames ")
    parser.add_argument(
        "--pl-acm-vcm",
        action='store_true',
        default=False,
        help="Force the PL Sync block into ACM/VCM mode in order to process "
        "all PLFRAMEs regardless of PLS. Note this option affects the PL Sync "
        "block only. The remaining blocks still operate in CCM mode.")
    parser.add_argument("-r",
                        "--rolloff",
                        type=eng_float,
                        choices=[0.35, 0.25, 0.2],
                        default=eng_notation.num_to_str(float(0.2)),
                        help="Rolloff factor")
    parser.add_argument(
        "--rot-max-buf",
        default=None,
        type=int,
        help="Target maximum size for the rotator block's output buffer")
    parser.add_argument("--rrc-delay",
                        type=int,
                        default=10,
                        help="RRC filter delay in symbol periods")
    parser.add_argument(
        "--rrc-nfilts",
        type=int,
        default=32,
        help="Number of branches on the polyphase RRC filter if using the  "
        "in-tree symbol synchronizer")
    parser.add_argument(
        "--spectral-inversion",
        action='store_true',
        default=False,
        help="Whether the input is spectrally inverted (LO freq. > RF freq.)")
    parser.add_argument("-o",
                        "--sps",
                        type=eng_float,
                        default=eng_notation.num_to_str(float(2)),
                        help="Oversampling ratio in samples per symbol")
    parser.add_argument("-s",
                        "--sym-rate",
                        type=eng_float,
                        default=eng_notation.num_to_str(float(1000000)),
                        help="Symbol rate in bauds")
    parser.add_argument("--sym-sync-damping",
                        type=eng_float,
                        default=eng_notation.num_to_str(float(1.0)),
                        help="Symbol synchronizer's damping factor")
    parser.add_argument("--sym-sync-loop-bw",
                        type=eng_float,
                        default=eng_notation.num_to_str(float(0.0045)),
                        help="Symbol synchronizer's loop bandwidth")
    parser.add_argument(
        "--sym-sync-impl",
        choices=['in-tree', 'oot'],
        default="in-tree",
        help="Symbol synchronizer implementation to use: GNU Radio's "
        "in-tree block (\"in-tree\") or gr-dvbs2rx\'s block (\"oot\")")

    src_group = parser.add_argument_group('Source Options')
    src_group.add_argument("--source",
                           choices=["fd", "file", "rtl", "usrp"],
                           default="fd",
                           help="Source of the input IQ sample stream")
    src_group.add_argument("--in-fd",
                           type=intx,
                           default=0,
                           help="Input file descriptor used if source=fd")
    src_group.add_argument("--in-file",
                           type=str,
                           help="Input file used if source=file")
    src_group.add_argument(
        "--in-repeat",
        action='store_true',
        default=False,
        help="Read repeatedly from the input file if source=file")

    snk_group = parser.add_argument_group('Sink Options')
    snk_group.add_argument("--sink",
                           choices=["fd", "file"],
                           default="fd",
                           help="Sink for the output MPEG transport stream")
    snk_group.add_argument("--out-fd",
                           type=intx,
                           default=1,
                           help="Output file descriptor used if sink=fd")
    snk_group.add_argument("--out-file",
                           type=str,
                           help="Output file used if sink=file")

    rtl_group = parser.add_argument_group('RTL-SDR Options')
    rtl_group.add_argument(
        "--rtl-agc",
        action='store_true',
        default=False,
        help="Enable the RTL-SDR's tuner and demodulator AGC")
    rtl_dev_group = rtl_group.add_mutually_exclusive_group()
    rtl_dev_group.add_argument("--rtl-idx",
                               type=int,
                               default=0,
                               help="RTL-SDR device index")
    rtl_dev_group.add_argument("--rtl-serial",
                               type=str,
                               help="RTL-SDR serial number")

    usrp_group = parser.add_argument_group('USRP Options')
    usrp_group.add_argument("--usrp-addr", type=str, help="USRP address")
    usrp_group.add_argument("--usrp-antenna",
                            type=str,
                            default="TX/RX",
                            help="USRP antenna")

    options = parser.parse_args()

    if (options.source == "usrp" and options.usrp_addr is None):
        parser.error("argument --usrp-addr is required when --source=\"usrp\"")

    return options


def main():
    options = argument_parser()

    gui_mode = options.gui
    if (gui_mode):
        if sys.platform.startswith('linux'):
            try:
                x11 = ctypes.cdll.LoadLibrary('libX11.so')
                x11.XInitThreads()
            except:
                print("Warning: failed to XInitThreads()")

        if StrictVersion("4.5.0") <= StrictVersion(
                Qt.qVersion()) < StrictVersion("5.0.0"):
            style = gr.prefs().get_string('qtgui', 'style', 'raster')
            Qt.QApplication.setGraphicsSystem(style)
        qapp = Qt.QApplication(sys.argv)

    tb = dvbs2_rx(options)

    tb.start()
    if (gui_mode):
        tb.show()
    else:
        tb.wait()

    def sig_handler(sig=None, frame=None):
        tb.stop()
        tb.wait()
        if (gui_mode):
            Qt.QApplication.quit()
        else:
            sys.exit(0)

    signal.signal(signal.SIGINT, sig_handler)
    signal.signal(signal.SIGTERM, sig_handler)

    if (gui_mode):
        timer = Qt.QTimer()
        timer.start(500)
        timer.timeout.connect(lambda: None)
        qapp.exec_()


if __name__ == '__main__':
    main()
