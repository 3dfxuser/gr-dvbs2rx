/* -*- c++ -*- */
/*
 * Copyright (c) 2023 Igor Freire.
 *
 * This file is part of gr-dvbs2rx.
 *
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

#ifndef INCLUDED_DVBS2RX_GF_UTIL_H
#define INCLUDED_DVBS2RX_GF_UTIL_H

#include "gf.h"
#include <array>
#include <stdexcept>
#include <vector>


namespace gr {
namespace dvbs2rx {

typedef std::vector<unsigned char> u8_vector_t;

/**
 * @brief Build LUT to assist with GF(2) polynomial remainder computation
 *
 * The resulting LUT can be used to compute "y % x" more efficiently for any "y" and a
 * given "x". More specifically, it maps each possible input byte representative of a
 * dividend polynomial y to the bits that would leak in the succeeding bytes within the
 * remainder computation. In the end, the LUT allows for computing the remainder with one
 * iteration per byte, instead of one interation per bit.
 *
 * @tparam T Type whose bits represent the binary polynomial coefficients.
 * @param x Divisor polynomial.
 * @note The divisor should have degree less than or equal to "(sizeof(T) - 1) * 8".
 * @return std::array<T, 256> Byte-by-byte remainder look-up table.
 */
template <typename T>
std::array<T, 256> build_gf2_poly_rem_lut(const gf2_poly<T>& x)
{
    // As the divisor x is bit-shifted and XORed over the bits of an input byte, the
    // result leaks over at least x.degree() bits following the given byte. More
    // generally, the division of an input byte by x leaks over as many succeeding bytes
    // as we want to compute in advance, but the result always occupies the last
    // x.degree() bits within the designated leak space. For instance, suppose the divisor
    // is x = x^8 + x^3 + 1 (i.e., x = 0x109). If we wanted to compute 4 leak bytes in
    // advance for an input byte equal to 1, we would compute 0x100000000 % 0x109, which
    // results in 0x0000009A, with the non-zero part occupying the 8 least significant
    // bits of the 4 leak bytes. In contrast, if we wanted 2 leak bytes, we would compute
    // 0x10000 % 0x109, which yields 0x0041, again occupying the 8 least significant bits.
    // Here, compute the maximum number of leak bytes that type T can hold, assuming one
    // byte of T is already used to store the input byte (the dividend).
    const unsigned int n_leak_bytes = sizeof(T) - 1;

    // But make sure the leak space is enough to hold the remainder of division by x. Note
    // this verification implies the maximum acceptable degree of x is "n_leak_bytes * 8".
    if (x.degree() > static_cast<int>(n_leak_bytes) * 8)
        throw std::runtime_error("Failed to compute remainder LUT. Type T is too small.");

    std::array<T, 256> table;
    for (int i = 0; i < 256; i++) {
        T padded_in_byte = static_cast<T>(i) << (n_leak_bytes * 8);
        gf2_poly<T> y(padded_in_byte);
        table[i] = (y % x).get_poly();
    }
    return table;
}

/**
 * @brief Compute the remainder "y % x" of GF2 polynomials y and x using a LUT
 *
 * @tparam T Type whose bits represent the binary polynomial coefficients.
 * @param y Dividend GF(2) polynomial given by an array of bytes in network byte order
 * (big-endian), i.e., with the most significant byte at index 0.
 * @param y_size Size of the dividend polynomial y in bytes.
 * @param x Divisor GF(2) polynomial.
 * @param x_lut LUT generated by the `build_gf2_poly_rem_lut` function for polynomial x.
 * @return gf2_poly<T> Resulting remainder.
 */
template <typename T>
gf2_poly<T> gf2_poly_rem(const unsigned char* y,
                         const int y_size,
                         const gf2_poly<T>& x,
                         const std::array<T, 256>& x_lut)
{
    const int n_leak_bytes = sizeof(T) - 1; // see build_gf2_poly_rem_lut
    const T bits_after_msby = (n_leak_bytes - 1) * 8;
    const T leak_mask = (static_cast<T>(1) << (n_leak_bytes * 8)) - 1;

    // Over the first "y_size - n_leak_bytes" bytes, iteratively look up the leak that the
    // input byte introduces into the next n_leak_bytes bytes.
    T leak = 0;
    for (int i = 0; i < y_size - n_leak_bytes; i++) {
        // Incorporate the preceding leak into the input byte. The leak spans over
        // n_leak_bytes of the type-T word, and the resulting most significant byte (MSBy)
        // determines the next leak. The other bytes (other than the MSBy) from the
        // preceding leak continue to leak (are carried forward) over the next bytes.
        T padded_in_byte = static_cast<T>(y[i]) << bits_after_msby;
        uint8_t msby = (leak ^ padded_in_byte) >> bits_after_msby;
        T leak_carried_forward = (leak_mask & (leak << 8));
        leak = leak_carried_forward ^ x_lut[msby];
    }

    // Convert the last n_leak_bytes of the input vector into a word of type T.
    //
    // In doing so, note that:
    // - We assume the order of bytes on the input u8_vector y is the order in which they
    //   arrive on serialization, i.e., y[0] arrives first and y[size-1] arrives last.
    //   Also, we could assume y carries a word in network byte order (big-endian), with
    //   y[0] representing the most significant byte and y[size-1] the least.
    // - The last n_leak_bytes are converted into a word of type T in network byte order,
    //   For instance, with T = uint32_t, an input vector {0x0A, 0x0B, 0x0C, 0x0D} would
    //   be converted into an unsigned int equal to 0x0A0B0C0D.
    // - The last n_leak_bytes are guaranteed to fit in T, otherwise
    //   build_gf2_poly_rem_lut would have thrown an exception.
    T y_last_bytes = 0;
    for (int i = 0; i < std::min(n_leak_bytes, y_size); i++) {
        y_last_bytes ^= static_cast<T>(y[y_size - i - 1]) << (i * 8);
    }

    // Incorporate the leak from the preceding bytes, if any
    y_last_bytes ^= leak;

    return gf2_poly<T>(y_last_bytes) % x;
}

/**
 * @overload
 * @param y Dividend GF(2) polynomial given by a vector of bytes in network byte order.
 */
template <typename T>
gf2_poly<T>
gf2_poly_rem(const u8_vector_t& y, const gf2_poly<T>& x, const std::array<T, 256>& x_lut)
{
    return gf2_poly_rem(y.data(), y.size(), x, x_lut);
}

/**
 * @brief Test if bit is set
 *
 * @param x Bit register.
 * @param i_bit Target bit index.
 * @return true if bit is 1 and false otherwise.
 */
template <typename T>
inline bool is_bit_set(const T& x, int i_bit)
{
    return x & (static_cast<T>(1) << i_bit);
}

/**
 * @overload
 */
template <>
inline bool is_bit_set(const bitset192_t& x, int i_bit)
{
    return x.test(i_bit);
}

} // namespace dvbs2rx
} // namespace gr

#endif // INCLUDED_DVBS2RX_GF_UTIL_H